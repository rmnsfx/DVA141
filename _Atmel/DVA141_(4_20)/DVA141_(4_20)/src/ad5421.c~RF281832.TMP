/*
 * ad5421.h
 *
 * Created: 07.04.2016 11:22:54
 *  Author: savchenkors
 */ 

#include <spi.h>
#include <sercom.h>



#ifndef AD5421_H_
#define AD5421_H_



/******************************************************************************/
/* AD5421                                                                    */
/******************************************************************************/
/* Registers */
#define AD5421_REG_DAC_DATA				0x1
#define AD5421_REG_CTRL					0x2
#define AD5421_REG_OFFSET				0x3
#define AD5421_REG_GAIN					0x4
/* load dac and fault shared the same register number. Writing to it will cause
 * a dac load command, reading from it will return the fault status register */
#define AD5421_REG_LOAD_DAC				0x5
#define AD5421_REG_FAULT				0x5
#define AD5421_REG_FORCE_ALARM_CURRENT	0x6
#define AD5421_REG_RESET				0x7
#define AD5421_REG_START_CONVERSION		0x8
#define AD5421_REG_NOOP					0x9

#define AD5421_CTRL_WATCHDOG_TIME(x)	(((x) & 0x7) << 13)
#define AD5421_CTRL_WATCHDOG_DISABLE	(1 << 12)
#define AD5421_CTRL_AUTO_FAULT_READBACK	(1 << 11)
#define AD5421_CTRL_MIN_CURRENT			(1 << 9)
#define AD5421_CTRL_ADC_SOURCE_TEMP		(1 << 8)
#define AD5421_CTRL_ADC_ENABLE			(1 << 7)
#define AD5421_CTRL_PWR_DOWN_INT_VREF	(1 << 6)

#define AD5421_FAULT_SPI				(1 << 15)
#define AD5421_FAULT_PEC				(1 << 14)
#define AD5421_FAULT_OVER_CURRENT		(1 << 13)
#define AD5421_FAULT_UNDER_CURRENT		(1 << 12)
#define AD5421_FAULT_TEMP_OVER_140		(1 << 11)
#define AD5421_FAULT_TEMP_OVER_100		(1 << 10)
#define AD5421_FAULT_UNDER_VOLTAGE_6V	(1 << 9)
#define AD5421_FAULT_UNDER_VOLTAGE_12V	(1 << 8)

#define AD5421_READ						(1 << 7)



void AD5421_SetRegisterValue(uint8_t regAddress, uint16_t regValue)
{
	volatile unsigned char statuscode;
	uint8_t data[] = {0x00, 0x00, 0x00};
	
	data[0] = regAddress;
	data[1] = ((regValue & 0xFF00) >> 8);
	data[2] = ((regValue & 0x00FF) >> 0);
	
	port_pin_set_output_level(PIN_PA18, 0);
	statuscode = spi_write_buffer_wait(&spi_master_instance, data, 3);
	port_pin_set_output_level(PIN_PA18, 1);
}

uint16_t AD5421_GetRegisterValue(uint8_t regAddress)
{
	uint8_t data[] = {0x00, 0x00, 0x00};
	uint16_t receivedData = 0x00;
	volatile unsigned char statuscode;
	
	data[0] = regAddress | AD5421_READ;
	
	port_pin_set_output_level(PIN_PA18, 0);
	statuscode = spi_write_buffer_wait(&spi_master_instance, data, 3);
	port_pin_set_output_level(PIN_PA18, 1);
	
	delay_us(30);
	
	port_pin_set_output_level(PIN_PA18, 0);
	statuscode = spi_read_buffer_wait(&spi_master_instance, data, 3, 0);
	port_pin_set_output_level(PIN_PA18, 1);
	receivedData += (data[1] << 8);
	receivedData += (data[2] << 0);

	return receivedData;
}

uint16_t AD5421_Init(void)
{
	uint16_t status = 1;
	
	port_pin_set_output_level(PIN_PA18, 1);

	AD5421_SetRegisterValue(AD5421_REG_CTRL,
	AD5421_CTRL_WATCHDOG_DISABLE |
	AD5421_CTRL_MIN_CURRENT	|
	//AD5421_CTRL_ADC_SOURCE_TEMP	|
	AD5421_CTRL_ADC_ENABLE
	);
	
	if(AD5421_GetRegisterValue(AD5421_REG_CTRL) == 0x1280)
	{
		status = 0x0;
	}
	
	return (status);
}

uint16_t AD5421_GetTemperature(void)
{
	uint16_t temp = 0;
	temp = (uint16_t) AD5421_GetRegisterValue(AD5421_REG_FAULT) & 0xFF;
	temp = temp - 128;
	temp = temp * 1.771;
	temp = 125 - temp;
	
	return temp;
	
}


#endif /* AD5421_H_ */